#/usr/bin/env python

import bravais
import numpy as np
import numpy.linalg

def read_flfrc(flfrc):
    """Read file 'flfrc' with force constants generated by 'q2r.x'."""

    with open(flfrc) as data:
        # read all words of current line:

        def cells():
            return data.readline().split()

        # read table:

        def table(rows):
            return np.array([map(float, cells()) for row in range(rows)])

        # read crystal structure:

        tmp = cells()
        ntyp, nat, ibrav = list(map(int, tmp[:3]))
        celldim = list(map(float, tmp[3:]))

        if ibrav == 0:
            at = table(3)
        elif ibrav == 4:
            at = np.empty((3, 3))

            at[0] = np.array([ 1.0,        0.0, 0.0]) * celldim[0]
            at[1] = np.array([-1.0, np.sqrt(3), 0.0]) * celldim[0] / 2
            at[2] = np.array([ 0.0,        0.0, 1.0]) * celldim[0] * celldim[2]
        else:
            print('Bravais lattice unknown')
            return

        # read palette of atomic species and masses:

        atm = []
        amass = np.empty(ntyp)

        for nt in range(ntyp):
            tmp = cells()

            atm.append(tmp[1][1:3])
            amass[nt] = float(tmp[-1])

        # read types and positions of individual atoms:

        ityp = np.empty(nat, dtype=int)
        tau = np.empty((nat, 3))

        for na in range(nat):
            tmp = cells()

            ityp[na] = int(tmp[1]) - 1
            tau[na, :] = list(map(float, tmp[2:5]))

        tau *= celldim[0]

        # read macroscopic dielectric function and effective charges:

        lrigid = cells()[0] == 'T'

        if lrigid:
            epsil = table(3)

            zeu = np.empty((nat, 3, 3))

            for na in range(nat):
                zeu[na] = table(3)

        # read interatomic force constants:

        nr1, nr2, nr3 = map(int, cells())

        phid = np.empty((nat, nat, nr1, nr2, nr3, 3, 3))

        for j1 in range(3):
            for j2 in range(3):
                for na1 in range(nat):
                    for na2 in range(nat):
                        cells() # skip line with j1, j2, na2, na2

                        for m3 in range(nr3):
                            for m2 in range(nr2):
                                for m1 in range(nr1):
                                    phid[na1, na2, m1, m2, m3, j1, j2] \
                                        = float(cells()[-1])

    # return force constants, masses, and geometry:

    return [phid, amass[ityp], at, tau]

def asr(phid):
    """Apply simple acoustic sum rule correction to force constants."""

    nat, nr1, nr2, nr3 = phid.shape[1:5]

    for na1 in range(nat):
        phid[na1, na1, 0, 0, 0] = -sum(
        phid[na1, na2, m1, m2, m3]
            for na2 in range(nat)
            for m1 in range(nr1)
            for m2 in range(nr2)
            for m3 in range(nr3)
            if na1 != na2 or m1 or m2 or m3)

def dynamical_matrix(comm, phid, amass, at, tau, eps=1e-7):
    """Set up dynamical matrix for force constants, masses, and geometry."""

    nat, nr1, nr2, nr3 = phid.shape[1:5]

    supercells = [-1, 0, 1] # indices of central and neighboring supercells

    maxdim = nat ** 2 * nr1 * nr2 * nr3 * len(supercells) ** 3 // comm.size

    atoms = np.empty((maxdim, 2), dtype=np.int8) # atom indices
    cells = np.empty((maxdim, 3), dtype=np.int8) # cell indices
    const = np.empty((maxdim, 3, 3)) # force constants divided by masses

    n = 0 # 'spring' counter (per process)
    N = 0 # 'spring' counter (overall)

    for m1 in range(nr1):
        for m2 in range(nr2):
            for m3 in range(nr3):
                N += 1

                if N % comm.size != comm.rank:
                    continue

                # determine equivalent unit cells within considered supercells:

                copies = np.array([[
                        m1 + M1 * nr1,
                        m2 + M2 * nr2,
                        m3 + M3 * nr3,
                        ]
                    for M1 in supercells
                    for M2 in supercells
                    for M3 in supercells
                    ])

                # calculate corresponding translation vectors:

                shifts = [np.dot(copy, at) for copy in copies]

                for na1 in range(nat):
                    for na2 in range(nat):
                        # find equivalent bond(s) within Wigner-Seitz cell:

                        bonds = [r + tau[na1] - tau[na2] for r in shifts]
                        lengths = [np.sqrt(np.dot(r, r)) for r in bonds]
                        length = min(lengths)

                        selected = copies[np.where(abs(lengths - length) < eps)]

                        # undo supercell double counting and divide by masses:

                        C = phid[na1, na2, m1, m2, m3] / (
                            len(selected) * np.sqrt(amass[na1] * amass[na2]))

                        # save data for dynamical matrix calculation:

                        for R in selected:
                            atoms[n] = [na1, na2]
                            cells[n] = R
                            const[n] = C

                            n += 1

    # gather data of all processes:

    dims = np.array(comm.allgather(n))
    dim = dims.sum()

    allatoms = np.empty((dim, 2), dtype=np.int8)
    allcells = np.empty((dim, 3), dtype=np.int8)
    allconst = np.empty((dim, 3, 3))

    comm.Allgatherv(atoms[:n], (allatoms, dims * 2))
    comm.Allgatherv(cells[:n], (allcells, dims * 3))
    comm.Allgatherv(const[:n], (allconst, dims * 9))

    # (see cdef _p_message message_vector in mpi4py/src/mpi4py/MPI/msgbuffer.pxi
    # for possible formats of second argument 'recvbuf')

    # return function to calculate dynamical matrix for arbitrary q points:

    def calculate_dynamical_matrix(q1=0, q2=0, q3=0):
        q = np.array([q1, q2, q3])
        D = np.zeros((3 * nat, 3 * nat), dtype=complex)

        for (na1, na2), R, C in zip(allatoms, allcells, allconst):
            D[na1::nat, na2::nat] += C * np.exp(1j * np.dot(R, q))

        return D

    return calculate_dynamical_matrix

def frequencies(dynamical_matrix):
    """Calculate phonon frequencies."""

    w2 = numpy.linalg.eigvalsh(dynamical_matrix)

    return np.sign(w2) * np.sqrt(np.absolute(w2))

def frequencies_and_displacements(dynamical_matrix):
    """Calculate phonon frequencies and displacements."""

    w2, e = numpy.linalg.eigh(dynamical_matrix)

    return np.sign(w2) * np.sqrt(np.absolute(w2)), e

def band_order(w, e, by_mean=True):
    """Sort bands by similarity of displacements at neighboring q points."""

    N, bands = w.shape

    order = np.empty((N, bands), dtype=int)

    n0 = 0
    order[n0] = range(bands)

    for n in range(1, N):
        for nu in range(bands):
            order[n, nu] = max(range(bands), key=lambda mu: np.absolute(
                np.dot(e[n0, :, order[n0, nu]], e[n, :, mu].conj())
                ))

        if np.all(np.absolute(np.diff(w[n])) > 1e-10): # no degeneracy?
            n0 = n

    if by_mean:
        reorder = sorted(range(bands), key=lambda nu: w[:, order[:, nu]].sum())

        order[:] = np.copy(order[:, reorder])

    return order

def dispersion(comm, dynamical_matrix, q,
    order=False, vectors=False, rotate=False):
    """Calculate dispersion and eigenvectors along given q path."""

    bands = dynamical_matrix().shape[0]

    sizes = np.empty(comm.size, dtype=int)
    sizes[:] = len(q) // comm.size
    sizes[:len(q) % comm.size] += 1

    my_q = np.empty((sizes[comm.rank], 2))
    my_w = np.empty((sizes[comm.rank], bands))

    if order or vectors:
        my_e = np.empty((sizes[comm.rank], bands, bands), dtype=complex)

    comm.Scatterv((q, 2 * sizes), my_q)

    for n, (q1, q2) in enumerate(my_q):
        if order or vectors:
            my_w[n], my_e[n] = frequencies_and_displacements(
                dynamical_matrix(q1, q2))

            if rotate:
                x, y = q1 * bravais.u1 + q2 * bravais.u2
                phi = np.arctan2(y, x)

                nat = bands // 3

                for na in range(nat):
                    for nu in range(bands):
                        my_e[n, [na, na + nat], nu] = bravais.rotate(
                        my_e[n, [na, na + nat], nu], -phi)
        else:
            my_w[n] = frequencies(dynamical_matrix(q1, q2))

    w = np.empty((len(q), bands))
    comm.Allgatherv(my_w, (w, bands * sizes))

    if order or vectors:
        e = np.empty((len(q), bands, bands), dtype=complex)
        comm.Allgatherv(my_e, (e, bands ** 2 * sizes))

    if order:
        if comm.rank == 0:
            o = band_order(w, e)

            for n in range(len(q)):
                w[n] = w[n, o[n]]

        else:
            o = np.empty((len(q), bands), dtype=int)

        comm.Bcast(w)
        comm.Bcast(o)

    return (w, e, o) if vectors and order else \
        (w, e) if vectors else (w, o) if order else w

def dispersion_full(comm, dynamical_matrix, nq, order=False):
    """Calculate dispersion on wedge, order bands and complete data."""

    Q = np.array(sorted(bravais.irreducibles(nq)))

    if order:
        W, E = dispersion(comm, dynamical_matrix, 2 * np.pi / nq * Q,
            order=False, vectors=True, rotate=True)

        O = np.empty((len(Q), W.shape[1]), dtype=int)

        if comm.rank == 0:
            main_path = [n for n in range(len(Q)) if not Q[n, 0]]
            main_order = band_order(W[main_path], E[main_path])

            for n, N in zip(main_path, main_order):
                side_path = [m for m in range(len(Q)) if Q[m, 1] == Q[n, 1]]
                side_order = band_order(W[side_path], E[side_path],
                    by_mean=False)

                for m, M in zip(side_path, side_order):
                    O[m] = M[N]
                    W[m] = W[m, O[m]]

        comm.Bcast(W)
        comm.Bcast(O)

    else:
        W = dispersion(comm, dynamical_matrix, 2 * np.pi / nq * Q)

    w = np.empty((nq, nq, W.shape[1]))

    if order:
        o = np.empty((nq, nq, W.shape[1]))

    if comm.rank == 0:
        w[:] = np.nan

        if order:
            o[:] = np.nan

        for n, (q1, q2) in enumerate(Q):
            w[q1, q2] = W[n]

            if order:
                o[q1, q2] = O[n]

        for nu in range(w.shape[2]):
            bravais.complete(w[:, :, nu])

            if order:
                bravais.complete(o[:, :, nu])

    comm.Bcast(w)

    if order:
        comm.Bcast(o)

    return (w, o.astype(int)) if order else w
